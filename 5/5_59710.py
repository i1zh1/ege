inp = int(input())

bininp = list(map(int, bin(inp)[2:]))
temp = []
if inp % 3 == 0:
    for i in range(len(bininp)):                #я не знаю как это работает
        temp.append(bininp[len(bininp)-i-1])    #но оно работает
    print(temp)                                 #если бы я писал это заново я бы сделал проще
    for i in range(3):                          #но оно работает 
        bininp.append(temp[2-i])                #а работает - не трогай. но вообще я ввожу список который из себя представляет перевернутое исходное двоичное число,
                                                #а потом добавляю к исходному первые 3 элемента перевернутого списка. итого я добавил 3 последних элемента исходного числа...
                                                #НО ЭТО В ТЕОРИИ. НА ПРАКТИКЕ Я ВООБЩЕ НЕ ПРЕДСТАВЛЯЮ КАК МОЙ КОД ЭТО ДЕЛАЕТ
                 
elif inp % 3 !=0:                               
    bininp += list(map(int, bin((inp%3)*3)[2:]))

print(int(''.join(map(str, bininp)), 2))    #врочем код правильный, ответ верный 

print('===================')

for n in range (1,1000):    #решение Сани(почти полностью)
    n2= f'{n:b}'
    if n%3==0:
        n2+= n2[-3:]
    else:
        ost= (n%3)*3
        ost2= f'{ost:b}'
        n2+= ost2
    r= int(n2, 2)   
    if r>=76:
        print(n)
        break

print(r)